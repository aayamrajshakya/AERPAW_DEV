/**
 * Namf_Communication
 * AMF Communication Service Â© 2019, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.0.alpha-1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "N1N2MessageCollectionDocumentApiImpl.h"
#include "itti.hpp"

#include "amf_app.hpp"
#include "amf_sbi.hpp"
#include "pdu_session_context.hpp"
#include "conversions.hpp"
#include "output_wrapper.hpp"

using namespace amf_application;

extern itti_mw* itti_inst;
extern amf_app* amf_app_inst;

namespace oai {
namespace amf {
namespace api {

using namespace oai::amf::model;

N1N2MessageCollectionDocumentApiImpl::N1N2MessageCollectionDocumentApiImpl(
    std::shared_ptr<Pistache::Rest::Router> rtr,
    amf_application::amf_app* amf_app_inst)
    : N1N2MessageCollectionDocumentApi(rtr), m_amf_app(amf_app_inst) {}

void N1N2MessageCollectionDocumentApiImpl::n1_n2_message_transfer(
    const std::string& ueContextId,
    std::unordered_map<std::string, mime_part>& parts,
    Pistache::Http::ResponseWriter& response) {
  Logger::amf_server().debug(
      "Receive N1N2MessageTransfer Request, handling...");

  nlohmann::json response_json = {};
  response_json["cause"] =
      n1_n2_message_transfer_cause_e2str[N1_MSG_NOT_TRANSFERRED];
  Pistache::Http::Code code = Pistache::Http::Code::Bad_Request;

  std::string supi = ueContextId;

  N1N2MessageTransferReqData n1N2MessageTransferReqData = {};
  nlohmann::json::parse(parts[JSON_CONTENT_ID_MIME].body.c_str())
      .get_to(n1N2MessageTransferReqData);

  bool request_valid = true;
  bstring n1sm       = nullptr;
  bstring n2sm       = nullptr;
  bstring nrppa_pdu  = nullptr;
  bstring routing_id = nullptr;

  auto itti_msg = std::make_shared<itti_n1n2_message_transfer_request>(
      AMF_SERVER, TASK_AMF_APP);  // TODO: May not be used
  itti_msg->supi = ueContextId;
  Logger::amf_server().debug("SUPI %s", ueContextId.c_str());

  if (n1N2MessageTransferReqData.n2InfoContainerIsSet()) {
    // N2 Container Present
    Logger::amf_server().debug("N2InfoContainer is present, handling...");

    std::string n2_content_id = {};
    std::string ngap_type     = {};

    // Check N2 Information Class
    switch (n1N2MessageTransferReqData.getN2InfoContainer()
                .getN2InformationClass()
                .getEnumValue()) {
      case N2InformationClass_anyOf::eN2InformationClass_anyOf::SM: {
        Logger::amf_server().debug("N2 Information Class: SM");

        // Validate Content ID
        n2_content_id = n1N2MessageTransferReqData.getN2InfoContainer()
                            .getSmInfo()
                            .getN2InfoContent()
                            .getNgapData()
                            .getContentId();
        Logger::amf_server().debug("n2_content_id: %s", n2_content_id.c_str());
        // Check whether N2 Content Id is valid with MIME part
        if (parts.count(n2_content_id) == 0 ||
            parts[n2_content_id].body.size() == 0) {
          Logger::amf_server().error("Missing n2sm MIME part");
          send_response(code, response_json, response);
          return;
        }

        // NGAP IE Type
        nlohmann::json ngap_ie_type_json = {};
        to_json(
            ngap_ie_type_json, n1N2MessageTransferReqData.getN2InfoContainer()
                                   .getSmInfo()
                                   .getN2InfoContent()
                                   .getNgapIeType()
                                   .getValue());
        ngap_type = ngap_ie_type_json.get<std::string>();
        Logger::amf_server().debug("NGAP IE Type: %s", ngap_type.c_str());
        // Set NGAP type
        itti_msg->n2sm_info_type = ngap_type;

        Logger::amf_server().debug(
            "Key for PDU Session Context: SUPI (%s)", supi.c_str());
        std::shared_ptr<pdu_session_context> psc = {};

        if (!amf_app_inst->find_pdu_session_context(
                supi, (uint8_t) n1N2MessageTransferReqData.getPduSessionId(),
                psc)) {
          Logger::amf_server().error(
              "Cannot get PDU Session Context with SUPI (%s)", supi.c_str());
          send_response(code, response_json, response);
          return;
        }

        conv::msg_str_2_msg_hex(parts[n2_content_id].body, n2sm);
        // Store N2 SM in PDU Session Context
        psc->n2sm              = bstrcpy(n2sm);
        psc->is_n2sm_avaliable = true;

        itti_msg->n2sm           = bstrcpy(n2sm);
        itti_msg->is_n2sm_set    = true;
        itti_msg->n2sm_info_type = ngap_type;

        itti_msg->pdu_session_id =
            (uint8_t) n1N2MessageTransferReqData.getPduSessionId();

      } break;

      case N2InformationClass_anyOf::eN2InformationClass_anyOf::NRPPA: {
        Logger::amf_server().debug("N2 Information Class: NRPPA");
        n2_content_id = n1N2MessageTransferReqData.getN2InfoContainer()
                            .getNrppaInfo()
                            .getNrppaPdu()
                            .getNgapData()
                            .getContentId();
        Logger::amf_server().debug("N2 Content Id: %s", n2_content_id.c_str());

        // Check whether N2 Content Id is valid with MIME part
        if (parts.count(n2_content_id) == 0 ||
            parts[n2_content_id].body.size() == 0) {
          Logger::amf_server().error("Missing n2sm MIME part");
          send_response(code, response_json, response);
          return;
        }

        // NGAP IE Type
        nlohmann::json ngap_ie_type_json = {};
        to_json(
            ngap_ie_type_json, n1N2MessageTransferReqData.getN2InfoContainer()
                                   .getNrppaInfo()
                                   .getNrppaPdu()
                                   .getNgapIeType()
                                   .getValue());
        ngap_type = ngap_ie_type_json.get<std::string>();
        Logger::amf_server().debug("NGAP IE Type: %s", ngap_type.c_str());
        // Set NGAP type
        itti_msg->n2sm_info_type = ngap_type;

        // NRPPA PDU
        conv::msg_str_2_msg_hex(parts[n2_content_id].body, nrppa_pdu);
        conv::string_2_bstring(
            n1N2MessageTransferReqData.getN2InfoContainer()
                .getNrppaInfo()
                .getNfId(),
            routing_id);
        itti_msg->nrppa_pdu        = bstrcpy(nrppa_pdu);
        itti_msg->routing_id       = bstrcpy(routing_id);
        itti_msg->is_nrppa_pdu_set = true;

      } break;

      default: {
        /*
        response_json["cause"] =
            n1_n2_message_transfer_cause_e2str[N1_MSG_NOT_TRANSFERRED];
        code = Pistache::Http::Code::Bad_Request;
        send_response(code, response_json, response);
        */
        response.send(
            Pistache::Http::Code::Ok,
            "N1N2MessageCollectionDocumentApiImpl::n1_n2_message_transfer API "
            "(Unsupported N2 Message Class)");
        return;
      }
    }
  }

  if (n1N2MessageTransferReqData.n1MessageContainerIsSet()) {
    Logger::amf_server().debug("N1MessageContainer is present, handling...");

    switch (n1N2MessageTransferReqData.getN1MessageContainer()
                .getN1MessageClass()
                .getEnumValue()) {
      case N1MessageClass_anyOf::eN1MessageClass_anyOf::SM: {
        // N1 SM Container Present
        Logger::amf_server().debug(
            "Key for PDU Session Context: SUPI (%s)", supi.c_str());
        std::shared_ptr<pdu_session_context> psc = {};
        if (!amf_app_inst->find_pdu_session_context(
                supi, (uint8_t) n1N2MessageTransferReqData.getPduSessionId(),
                psc)) {
          Logger::amf_server().error(
              "Cannot get PDU Session Context with SUPI (%s)", supi.c_str());
          send_response(code, response_json, response);
          return;
        }

        std::string n1_content_id =
            n1N2MessageTransferReqData.getN1MessageContainer()
                .getN1MessageContent()
                .getContentId();
        Logger::amf_server().debug("N1 Content Id: %s", n1_content_id.c_str());

        if (parts.count(n1_content_id) == 0 ||
            parts[n1_content_id].body.size() == 0) {
          send_response(code, response_json, response);
          return;
        }

        conv::msg_str_2_msg_hex(
            parts[n1_content_id].body.substr(
                0, parts[n1_content_id].body.length()),
            n1sm);
        output_wrapper::print_buffer(
            "amf_server", "Received N1 SM", (uint8_t*) bdata(n1sm),
            blength(n1sm));
        // Store N1 SM in PDU Session Context
        psc->n1sm              = bstrcpy(n1sm);
        psc->is_n1sm_avaliable = true;

        itti_msg->n1sm        = bstrcpy(n1sm);
        itti_msg->is_n1sm_set = true;
        itti_msg->pdu_session_id =
            (uint8_t) n1N2MessageTransferReqData.getPduSessionId();

      } break;

      case N1MessageClass_anyOf::eN1MessageClass_anyOf::LPP: {
        // N1 LPP Container Present
        // TODO:
        response.send(
            Pistache::Http::Code::Ok,
            "N1N2MessageCollectionDocumentApiImpl::n1_n2_message_transfer API "
            "(Unsupported N1 Message Class: LPP)");
        return;
      } break;

      default: {
        // TODO:
        response.send(
            Pistache::Http::Code::Ok,
            "N1N2MessageCollectionDocumentApiImpl::n1_n2_message_transfer API "
            "(Unsupported N1 Message Class)");
        return;
      }
    }
  }

  if (!request_valid) {
    code = Pistache::Http::Code::Bad_Request;
    response_json["cause"] =
        n1_n2_message_transfer_cause_e2str[N1_MSG_NOT_TRANSFERRED];
    // Send response to the NF Service Consumer (e.g., SMF)
    response.send(code, response_json.dump().c_str());
    return;
  }

  response_json["cause"] =
      n1_n2_message_transfer_cause_e2str[N1_N2_TRANSFER_INITIATED];
  code = Pistache::Http::Code::Ok;

  // For Paging
  if (n1N2MessageTransferReqData.ppiIsSet()) {
    itti_msg->is_ppi_set = true;
    itti_msg->ppi        = n1N2MessageTransferReqData.getPpi();
    response_json["cause"] =
        n1_n2_message_transfer_cause_e2str[ATTEMPTING_TO_REACH_UE];
    code = Pistache::Http::Code::Accepted;
  } else {
    itti_msg->is_ppi_set = false;
  }

  // Send response to the NF Service Consumer (e.g., SMF)
  response.send(code, response_json.dump().c_str());

  // Process N1N2 Message Transfer Request in AMF APP
  int ret = itti_inst->send_msg(itti_msg);
  if (0 != ret) {
    Logger::amf_server().error(
        "Could not send ITTI message %s to task TASK_AMF_N2",
        itti_msg->get_msg_name());
  }

  bdestroy_wrapper(&n1sm);
  bdestroy_wrapper(&n2sm);
  bdestroy_wrapper(&nrppa_pdu);
  bdestroy_wrapper(&routing_id);
}

void N1N2MessageCollectionDocumentApiImpl::send_response(
    const Pistache::Http::Code& code, const nlohmann::json& response_json,
    Pistache::Http::ResponseWriter& response) {
  response.send(code, response_json.dump().c_str());
}

}  // namespace api
}  // namespace amf
}  // namespace oai
