/**
 * Npcf_SMPolicyControl API
 * Session Management Policy Control Service Â© 2023, 3GPP Organizational
 * Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "QosMonitoringData.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::pcf {

QosMonitoringData::QosMonitoringData() {
  m_QmId               = "";
  m_RepThreshDl        = 0;
  m_RepThreshDlIsSet   = false;
  m_RepThreshUl        = 0;
  m_RepThreshUlIsSet   = false;
  m_RepThreshRp        = 0;
  m_RepThreshRpIsSet   = false;
  m_WaitTime           = 0;
  m_WaitTimeIsSet      = false;
  m_RepPeriod          = 0;
  m_RepPeriodIsSet     = false;
  m_NotifyUri          = "";
  m_NotifyUriIsSet     = false;
  m_NotifyCorreId      = "";
  m_NotifyCorreIdIsSet = false;
}

void QosMonitoringData::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool QosMonitoringData::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool QosMonitoringData::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "QosMonitoringData" : pathPrefix;

  /* ReqQosMonParams */ {
    const std::vector<oai::model::pcf::RequestedQosMonitoringParameter>& value =
        m_ReqQosMonParams;
    const std::string currentValuePath = _pathPrefix + ".reqQosMonParams";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const oai::model::pcf::RequestedQosMonitoringParameter& value :
           value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".reqQosMonParams") &&
                  success;

        i++;
      }
    }
  }

  /* RepFreqs */ {
    const std::vector<oai::model::pcf::ReportingFrequency>& value = m_RepFreqs;
    const std::string currentValuePath = _pathPrefix + ".repFreqs";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const oai::model::pcf::ReportingFrequency& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success =
            value.validate(msg, currentValuePath + ".repFreqs") && success;

        i++;
      }
    }
  }

  return success;
}

bool QosMonitoringData::operator==(const QosMonitoringData& rhs) const {
  return

      (getQmId() == rhs.getQmId()) &&

      (getReqQosMonParams() == rhs.getReqQosMonParams()) &&

      (getRepFreqs() == rhs.getRepFreqs()) &&

      ((!repThreshDlIsSet() && !rhs.repThreshDlIsSet()) ||
       (repThreshDlIsSet() && rhs.repThreshDlIsSet() &&
        getRepThreshDl() == rhs.getRepThreshDl())) &&

      ((!repThreshUlIsSet() && !rhs.repThreshUlIsSet()) ||
       (repThreshUlIsSet() && rhs.repThreshUlIsSet() &&
        getRepThreshUl() == rhs.getRepThreshUl())) &&

      ((!repThreshRpIsSet() && !rhs.repThreshRpIsSet()) ||
       (repThreshRpIsSet() && rhs.repThreshRpIsSet() &&
        getRepThreshRp() == rhs.getRepThreshRp())) &&

      ((!waitTimeIsSet() && !rhs.waitTimeIsSet()) ||
       (waitTimeIsSet() && rhs.waitTimeIsSet() &&
        getWaitTime() == rhs.getWaitTime())) &&

      ((!repPeriodIsSet() && !rhs.repPeriodIsSet()) ||
       (repPeriodIsSet() && rhs.repPeriodIsSet() &&
        getRepPeriod() == rhs.getRepPeriod())) &&

      ((!notifyUriIsSet() && !rhs.notifyUriIsSet()) ||
       (notifyUriIsSet() && rhs.notifyUriIsSet() &&
        getNotifyUri() == rhs.getNotifyUri())) &&

      ((!notifyCorreIdIsSet() && !rhs.notifyCorreIdIsSet()) ||
       (notifyCorreIdIsSet() && rhs.notifyCorreIdIsSet() &&
        getNotifyCorreId() == rhs.getNotifyCorreId()))

          ;
}

bool QosMonitoringData::operator!=(const QosMonitoringData& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const QosMonitoringData& o) {
  j                    = nlohmann::json();
  j["qmId"]            = o.m_QmId;
  j["reqQosMonParams"] = o.m_ReqQosMonParams;
  j["repFreqs"]        = o.m_RepFreqs;
  if (o.repThreshDlIsSet()) j["repThreshDl"] = o.m_RepThreshDl;
  if (o.repThreshUlIsSet()) j["repThreshUl"] = o.m_RepThreshUl;
  if (o.repThreshRpIsSet()) j["repThreshRp"] = o.m_RepThreshRp;
  if (o.waitTimeIsSet()) j["waitTime"] = o.m_WaitTime;
  if (o.repPeriodIsSet()) j["repPeriod"] = o.m_RepPeriod;
  if (o.notifyUriIsSet()) j["notifyUri"] = o.m_NotifyUri;
  if (o.notifyCorreIdIsSet()) j["notifyCorreId"] = o.m_NotifyCorreId;
}

void from_json(const nlohmann::json& j, QosMonitoringData& o) {
  j.at("qmId").get_to(o.m_QmId);
  j.at("reqQosMonParams").get_to(o.m_ReqQosMonParams);
  j.at("repFreqs").get_to(o.m_RepFreqs);
  if (j.find("repThreshDl") != j.end()) {
    j.at("repThreshDl").get_to(o.m_RepThreshDl);
    o.m_RepThreshDlIsSet = true;
  }
  if (j.find("repThreshUl") != j.end()) {
    j.at("repThreshUl").get_to(o.m_RepThreshUl);
    o.m_RepThreshUlIsSet = true;
  }
  if (j.find("repThreshRp") != j.end()) {
    j.at("repThreshRp").get_to(o.m_RepThreshRp);
    o.m_RepThreshRpIsSet = true;
  }
  if (j.find("waitTime") != j.end()) {
    j.at("waitTime").get_to(o.m_WaitTime);
    o.m_WaitTimeIsSet = true;
  }
  if (j.find("repPeriod") != j.end()) {
    j.at("repPeriod").get_to(o.m_RepPeriod);
    o.m_RepPeriodIsSet = true;
  }
  if (j.find("notifyUri") != j.end()) {
    j.at("notifyUri").get_to(o.m_NotifyUri);
    o.m_NotifyUriIsSet = true;
  }
  if (j.find("notifyCorreId") != j.end()) {
    j.at("notifyCorreId").get_to(o.m_NotifyCorreId);
    o.m_NotifyCorreIdIsSet = true;
  }
}

std::string QosMonitoringData::getQmId() const {
  return m_QmId;
}
void QosMonitoringData::setQmId(std::string const& value) {
  m_QmId = value;
}
std::vector<oai::model::pcf::RequestedQosMonitoringParameter>
QosMonitoringData::getReqQosMonParams() const {
  return m_ReqQosMonParams;
}
void QosMonitoringData::setReqQosMonParams(
    std::vector<oai::model::pcf::RequestedQosMonitoringParameter> const&
        value) {
  m_ReqQosMonParams = value;
}
std::vector<oai::model::pcf::ReportingFrequency>
QosMonitoringData::getRepFreqs() const {
  return m_RepFreqs;
}
void QosMonitoringData::setRepFreqs(
    std::vector<oai::model::pcf::ReportingFrequency> const& value) {
  m_RepFreqs = value;
}
int32_t QosMonitoringData::getRepThreshDl() const {
  return m_RepThreshDl;
}
void QosMonitoringData::setRepThreshDl(int32_t const value) {
  m_RepThreshDl      = value;
  m_RepThreshDlIsSet = true;
}
bool QosMonitoringData::repThreshDlIsSet() const {
  return m_RepThreshDlIsSet;
}
void QosMonitoringData::unsetRepThreshDl() {
  m_RepThreshDlIsSet = false;
}
int32_t QosMonitoringData::getRepThreshUl() const {
  return m_RepThreshUl;
}
void QosMonitoringData::setRepThreshUl(int32_t const value) {
  m_RepThreshUl      = value;
  m_RepThreshUlIsSet = true;
}
bool QosMonitoringData::repThreshUlIsSet() const {
  return m_RepThreshUlIsSet;
}
void QosMonitoringData::unsetRepThreshUl() {
  m_RepThreshUlIsSet = false;
}
int32_t QosMonitoringData::getRepThreshRp() const {
  return m_RepThreshRp;
}
void QosMonitoringData::setRepThreshRp(int32_t const value) {
  m_RepThreshRp      = value;
  m_RepThreshRpIsSet = true;
}
bool QosMonitoringData::repThreshRpIsSet() const {
  return m_RepThreshRpIsSet;
}
void QosMonitoringData::unsetRepThreshRp() {
  m_RepThreshRpIsSet = false;
}
int32_t QosMonitoringData::getWaitTime() const {
  return m_WaitTime;
}
void QosMonitoringData::setWaitTime(int32_t const value) {
  m_WaitTime      = value;
  m_WaitTimeIsSet = true;
}
bool QosMonitoringData::waitTimeIsSet() const {
  return m_WaitTimeIsSet;
}
void QosMonitoringData::unsetWaitTime() {
  m_WaitTimeIsSet = false;
}
int32_t QosMonitoringData::getRepPeriod() const {
  return m_RepPeriod;
}
void QosMonitoringData::setRepPeriod(int32_t const value) {
  m_RepPeriod      = value;
  m_RepPeriodIsSet = true;
}
bool QosMonitoringData::repPeriodIsSet() const {
  return m_RepPeriodIsSet;
}
void QosMonitoringData::unsetRepPeriod() {
  m_RepPeriodIsSet = false;
}
std::string QosMonitoringData::getNotifyUri() const {
  return m_NotifyUri;
}
void QosMonitoringData::setNotifyUri(std::string const& value) {
  m_NotifyUri      = value;
  m_NotifyUriIsSet = true;
}
bool QosMonitoringData::notifyUriIsSet() const {
  return m_NotifyUriIsSet;
}
void QosMonitoringData::unsetNotifyUri() {
  m_NotifyUriIsSet = false;
}
std::string QosMonitoringData::getNotifyCorreId() const {
  return m_NotifyCorreId;
}
void QosMonitoringData::setNotifyCorreId(std::string const& value) {
  m_NotifyCorreId      = value;
  m_NotifyCorreIdIsSet = true;
}
bool QosMonitoringData::notifyCorreIdIsSet() const {
  return m_NotifyCorreIdIsSet;
}
void QosMonitoringData::unsetNotifyCorreId() {
  m_NotifyCorreIdIsSet = false;
}

}  // namespace oai::model::pcf
