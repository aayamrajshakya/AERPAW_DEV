/**
 * Npcf_SMPolicyControl API
 * Session Management Policy Control Service Â© 2023, 3GPP Organizational
 * Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "QosMonitoringReport.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::pcf {

QosMonitoringReport::QosMonitoringReport() {
  m_UlDelaysIsSet = false;
  m_DlDelaysIsSet = false;
  m_RtDelaysIsSet = false;
}

void QosMonitoringReport::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool QosMonitoringReport::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool QosMonitoringReport::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "QosMonitoringReport" : pathPrefix;

  /* RefPccRuleIds */ {
    const std::vector<std::string>& value = m_RefPccRuleIds;
    const std::string currentValuePath    = _pathPrefix + ".refPccRuleIds";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const std::string& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        i++;
      }
    }
  }

  if (ulDelaysIsSet()) {
    const std::vector<int32_t>& value  = m_UlDelays;
    const std::string currentValuePath = _pathPrefix + ".ulDelays";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const int32_t& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        i++;
      }
    }
  }

  if (dlDelaysIsSet()) {
    const std::vector<int32_t>& value  = m_DlDelays;
    const std::string currentValuePath = _pathPrefix + ".dlDelays";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const int32_t& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        i++;
      }
    }
  }

  if (rtDelaysIsSet()) {
    const std::vector<int32_t>& value  = m_RtDelays;
    const std::string currentValuePath = _pathPrefix + ".rtDelays";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const int32_t& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        i++;
      }
    }
  }

  return success;
}

bool QosMonitoringReport::operator==(const QosMonitoringReport& rhs) const {
  return

      (getRefPccRuleIds() == rhs.getRefPccRuleIds()) &&

      ((!ulDelaysIsSet() && !rhs.ulDelaysIsSet()) ||
       (ulDelaysIsSet() && rhs.ulDelaysIsSet() &&
        getUlDelays() == rhs.getUlDelays())) &&

      ((!dlDelaysIsSet() && !rhs.dlDelaysIsSet()) ||
       (dlDelaysIsSet() && rhs.dlDelaysIsSet() &&
        getDlDelays() == rhs.getDlDelays())) &&

      ((!rtDelaysIsSet() && !rhs.rtDelaysIsSet()) ||
       (rtDelaysIsSet() && rhs.rtDelaysIsSet() &&
        getRtDelays() == rhs.getRtDelays()))

          ;
}

bool QosMonitoringReport::operator!=(const QosMonitoringReport& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const QosMonitoringReport& o) {
  j                  = nlohmann::json();
  j["refPccRuleIds"] = o.m_RefPccRuleIds;
  if (o.ulDelaysIsSet() || !o.m_UlDelays.empty()) j["ulDelays"] = o.m_UlDelays;
  if (o.dlDelaysIsSet() || !o.m_DlDelays.empty()) j["dlDelays"] = o.m_DlDelays;
  if (o.rtDelaysIsSet() || !o.m_RtDelays.empty()) j["rtDelays"] = o.m_RtDelays;
}

void from_json(const nlohmann::json& j, QosMonitoringReport& o) {
  j.at("refPccRuleIds").get_to(o.m_RefPccRuleIds);
  if (j.find("ulDelays") != j.end()) {
    j.at("ulDelays").get_to(o.m_UlDelays);
    o.m_UlDelaysIsSet = true;
  }
  if (j.find("dlDelays") != j.end()) {
    j.at("dlDelays").get_to(o.m_DlDelays);
    o.m_DlDelaysIsSet = true;
  }
  if (j.find("rtDelays") != j.end()) {
    j.at("rtDelays").get_to(o.m_RtDelays);
    o.m_RtDelaysIsSet = true;
  }
}

std::vector<std::string> QosMonitoringReport::getRefPccRuleIds() const {
  return m_RefPccRuleIds;
}
void QosMonitoringReport::setRefPccRuleIds(
    std::vector<std::string> const& value) {
  m_RefPccRuleIds = value;
}
std::vector<int32_t> QosMonitoringReport::getUlDelays() const {
  return m_UlDelays;
}
void QosMonitoringReport::setUlDelays(std::vector<int32_t> const value) {
  m_UlDelays      = value;
  m_UlDelaysIsSet = true;
}
bool QosMonitoringReport::ulDelaysIsSet() const {
  return m_UlDelaysIsSet;
}
void QosMonitoringReport::unsetUlDelays() {
  m_UlDelaysIsSet = false;
}
std::vector<int32_t> QosMonitoringReport::getDlDelays() const {
  return m_DlDelays;
}
void QosMonitoringReport::setDlDelays(std::vector<int32_t> const value) {
  m_DlDelays      = value;
  m_DlDelaysIsSet = true;
}
bool QosMonitoringReport::dlDelaysIsSet() const {
  return m_DlDelaysIsSet;
}
void QosMonitoringReport::unsetDlDelays() {
  m_DlDelaysIsSet = false;
}
std::vector<int32_t> QosMonitoringReport::getRtDelays() const {
  return m_RtDelays;
}
void QosMonitoringReport::setRtDelays(std::vector<int32_t> const value) {
  m_RtDelays      = value;
  m_RtDelaysIsSet = true;
}
bool QosMonitoringReport::rtDelaysIsSet() const {
  return m_RtDelaysIsSet;
}
void QosMonitoringReport::unsetRtDelays() {
  m_RtDelaysIsSet = false;
}

}  // namespace oai::model::pcf
