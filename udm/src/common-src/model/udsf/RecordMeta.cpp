/**
 * Nudsf_DataRepository
 * Nudsf Data Repository Service.   Â© 2022, 3GPP Organizational Partners (ARIB,
 * ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "RecordMeta.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::udsf {

RecordMeta::RecordMeta() {
  m_Ttl                    = "";
  m_TtlIsSet               = false;
  m_CallbackReference      = "";
  m_CallbackReferenceIsSet = false;
  m_TagsIsSet              = false;
}

void RecordMeta::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool RecordMeta::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool RecordMeta::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "RecordMeta" : pathPrefix;

  if (tagsIsSet()) {
    const std::map<std::string, std::vector<std::string>>& value = m_Tags;
    const std::string currentValuePath = _pathPrefix + ".tags";
  }

  return success;
}

bool RecordMeta::operator==(const RecordMeta& rhs) const {
  return

      ((!ttlIsSet() && !rhs.ttlIsSet()) ||
       (ttlIsSet() && rhs.ttlIsSet() && getTtl() == rhs.getTtl())) &&

      ((!callbackReferenceIsSet() && !rhs.callbackReferenceIsSet()) ||
       (callbackReferenceIsSet() && rhs.callbackReferenceIsSet() &&
        getCallbackReference() == rhs.getCallbackReference())) &&

      ((!tagsIsSet() && !rhs.tagsIsSet()) ||
       (tagsIsSet() && rhs.tagsIsSet() && getTags() == rhs.getTags()))

          ;
}

bool RecordMeta::operator!=(const RecordMeta& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const RecordMeta& o) {
  j = nlohmann::json();
  if (o.ttlIsSet()) j["ttl"] = o.m_Ttl;
  if (o.callbackReferenceIsSet())
    j["callbackReference"] = o.m_CallbackReference;
  if (o.tagsIsSet() || !o.m_Tags.empty()) j["tags"] = o.m_Tags;
}

void from_json(const nlohmann::json& j, RecordMeta& o) {
  if (j.find("ttl") != j.end()) {
    j.at("ttl").get_to(o.m_Ttl);
    o.m_TtlIsSet = true;
  }
  if (j.find("callbackReference") != j.end()) {
    j.at("callbackReference").get_to(o.m_CallbackReference);
    o.m_CallbackReferenceIsSet = true;
  }
  if (j.find("tags") != j.end()) {
    j.at("tags").get_to(o.m_Tags);
    o.m_TagsIsSet = true;
  }
}

std::string RecordMeta::getTtl() const {
  return m_Ttl;
}
void RecordMeta::setTtl(std::string const& value) {
  m_Ttl      = value;
  m_TtlIsSet = true;
}
bool RecordMeta::ttlIsSet() const {
  return m_TtlIsSet;
}
void RecordMeta::unsetTtl() {
  m_TtlIsSet = false;
}
std::string RecordMeta::getCallbackReference() const {
  return m_CallbackReference;
}
void RecordMeta::setCallbackReference(std::string const& value) {
  m_CallbackReference      = value;
  m_CallbackReferenceIsSet = true;
}
bool RecordMeta::callbackReferenceIsSet() const {
  return m_CallbackReferenceIsSet;
}
void RecordMeta::unsetCallbackReference() {
  m_CallbackReferenceIsSet = false;
}
std::map<std::string, std::vector<std::string>> RecordMeta::getTags() const {
  return m_Tags;
}
void RecordMeta::setTags(
    std::map<std::string, std::vector<std::string>> const& value) {
  m_Tags      = value;
  m_TagsIsSet = true;
}
bool RecordMeta::tagsIsSet() const {
  return m_TagsIsSet;
}
void RecordMeta::unsetTags() {
  m_TagsIsSet = false;
}

}  // namespace oai::model::udsf
