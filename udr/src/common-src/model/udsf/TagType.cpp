/**
 * Nudsf_DataRepository
 * Nudsf Data Repository Service.   Â© 2022, 3GPP Organizational Partners (ARIB,
 * ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "TagType.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::udsf {

TagType::TagType() {
  m_TagName       = "";
  m_Sort          = false;
  m_SortIsSet     = false;
  m_Presence      = false;
  m_PresenceIsSet = false;
}

void TagType::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool TagType::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool TagType::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success                  = true;
  const std::string _pathPrefix = pathPrefix.empty() ? "TagType" : pathPrefix;

  return success;
}

bool TagType::operator==(const TagType& rhs) const {
  return

      (getTagName() == rhs.getTagName()) &&

      (getKeyType() == rhs.getKeyType()) &&

      ((!sortIsSet() && !rhs.sortIsSet()) ||
       (sortIsSet() && rhs.sortIsSet() && isSort() == rhs.isSort())) &&

      ((!presenceIsSet() && !rhs.presenceIsSet()) ||
       (presenceIsSet() && rhs.presenceIsSet() &&
        isPresence() == rhs.isPresence()))

          ;
}

bool TagType::operator!=(const TagType& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const TagType& o) {
  j            = nlohmann::json();
  j["tagName"] = o.m_TagName;
  j["keyType"] = o.m_KeyType;
  if (o.sortIsSet()) j["sort"] = o.m_Sort;
  if (o.presenceIsSet()) j["presence"] = o.m_Presence;
}

void from_json(const nlohmann::json& j, TagType& o) {
  j.at("tagName").get_to(o.m_TagName);
  j.at("keyType").get_to(o.m_KeyType);
  if (j.find("sort") != j.end()) {
    j.at("sort").get_to(o.m_Sort);
    o.m_SortIsSet = true;
  }
  if (j.find("presence") != j.end()) {
    j.at("presence").get_to(o.m_Presence);
    o.m_PresenceIsSet = true;
  }
}

std::string TagType::getTagName() const {
  return m_TagName;
}
void TagType::setTagName(std::string const& value) {
  m_TagName = value;
}
oai::model::udsf::KeyType TagType::getKeyType() const {
  return m_KeyType;
}
void TagType::setKeyType(oai::model::udsf::KeyType const& value) {
  m_KeyType = value;
}
bool TagType::isSort() const {
  return m_Sort;
}
void TagType::setSort(bool const value) {
  m_Sort      = value;
  m_SortIsSet = true;
}
bool TagType::sortIsSet() const {
  return m_SortIsSet;
}
void TagType::unsetSort() {
  m_SortIsSet = false;
}
bool TagType::isPresence() const {
  return m_Presence;
}
void TagType::setPresence(bool const value) {
  m_Presence      = value;
  m_PresenceIsSet = true;
}
bool TagType::presenceIsSet() const {
  return m_PresenceIsSet;
}
void TagType::unsetPresence() {
  m_PresenceIsSet = false;
}

}  // namespace oai::model::udsf
