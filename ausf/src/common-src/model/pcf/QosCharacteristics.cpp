/**
 * Npcf_SMPolicyControl API
 * Session Management Policy Control Service Â© 2023, 3GPP Organizational
 * Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "QosCharacteristics.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::pcf {

QosCharacteristics::QosCharacteristics() {
  m_r_5qi                   = 0;
  m_PriorityLevel           = 0;
  m_PacketDelayBudget       = 0;
  m_PacketErrorRate         = "";
  m_AveragingWindow         = 2000;
  m_AveragingWindowIsSet    = false;
  m_MaxDataBurstVol         = 0;
  m_MaxDataBurstVolIsSet    = false;
  m_ExtMaxDataBurstVol      = 0;
  m_ExtMaxDataBurstVolIsSet = false;
}

void QosCharacteristics::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool QosCharacteristics::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool QosCharacteristics::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "QosCharacteristics" : pathPrefix;

  /* r_5qi */ {
    const int32_t& value               = m_r_5qi;
    const std::string currentValuePath = _pathPrefix + ".r5qi";

    if (value < 0) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
    if (value > 255) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 255;";
    }
  }

  /* PriorityLevel */ {
    const int32_t& value               = m_PriorityLevel;
    const std::string currentValuePath = _pathPrefix + ".priorityLevel";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 127) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 127;";
    }
  }

  /* PacketDelayBudget */ {
    const int32_t& value               = m_PacketDelayBudget;
    const std::string currentValuePath = _pathPrefix + ".packetDelayBudget";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
  }
  /*
  // PacketErrorRate
  {
    const std::string& value           = m_PacketErrorRate;
    const std::string currentValuePath = _pathPrefix + ".packetErrorRate";
  }
  */

  if (averagingWindowIsSet()) {
    const int32_t& value               = m_AveragingWindow;
    const std::string currentValuePath = _pathPrefix + ".averagingWindow";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 4095) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 4095;";
    }
  }

  if (maxDataBurstVolIsSet()) {
    const int32_t& value               = m_MaxDataBurstVol;
    const std::string currentValuePath = _pathPrefix + ".maxDataBurstVol";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 4095) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 4095;";
    }
  }

  if (extMaxDataBurstVolIsSet()) {
    const int32_t& value               = m_ExtMaxDataBurstVol;
    const std::string currentValuePath = _pathPrefix + ".extMaxDataBurstVol";

    if (value < 4096) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 4096;";
    }
    if (value > 2000000) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 2000000;";
    }
  }

  return success;
}

bool QosCharacteristics::operator==(const QosCharacteristics& rhs) const {
  return

      (getR5qi() == rhs.getR5qi()) &&

      (getResourceType() == rhs.getResourceType()) &&

      (getPriorityLevel() == rhs.getPriorityLevel()) &&

      (getPacketDelayBudget() == rhs.getPacketDelayBudget()) &&

      (getPacketErrorRate() == rhs.getPacketErrorRate()) &&

      ((!averagingWindowIsSet() && !rhs.averagingWindowIsSet()) ||
       (averagingWindowIsSet() && rhs.averagingWindowIsSet() &&
        getAveragingWindow() == rhs.getAveragingWindow())) &&

      ((!maxDataBurstVolIsSet() && !rhs.maxDataBurstVolIsSet()) ||
       (maxDataBurstVolIsSet() && rhs.maxDataBurstVolIsSet() &&
        getMaxDataBurstVol() == rhs.getMaxDataBurstVol())) &&

      ((!extMaxDataBurstVolIsSet() && !rhs.extMaxDataBurstVolIsSet()) ||
       (extMaxDataBurstVolIsSet() && rhs.extMaxDataBurstVolIsSet() &&
        getExtMaxDataBurstVol() == rhs.getExtMaxDataBurstVol()))

          ;
}

bool QosCharacteristics::operator!=(const QosCharacteristics& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const QosCharacteristics& o) {
  j                      = nlohmann::json();
  j["5qi"]               = o.m_r_5qi;
  j["resourceType"]      = o.m_ResourceType;
  j["priorityLevel"]     = o.m_PriorityLevel;
  j["packetDelayBudget"] = o.m_PacketDelayBudget;
  j["packetErrorRate"]   = o.m_PacketErrorRate;
  if (o.averagingWindowIsSet()) j["averagingWindow"] = o.m_AveragingWindow;
  if (o.maxDataBurstVolIsSet()) j["maxDataBurstVol"] = o.m_MaxDataBurstVol;
  if (o.extMaxDataBurstVolIsSet())
    j["extMaxDataBurstVol"] = o.m_ExtMaxDataBurstVol;
}

void from_json(const nlohmann::json& j, QosCharacteristics& o) {
  j.at("5qi").get_to(o.m_r_5qi);
  j.at("resourceType").get_to(o.m_ResourceType);
  j.at("priorityLevel").get_to(o.m_PriorityLevel);
  j.at("packetDelayBudget").get_to(o.m_PacketDelayBudget);
  j.at("packetErrorRate").get_to(o.m_PacketErrorRate);
  if (j.find("averagingWindow") != j.end()) {
    j.at("averagingWindow").get_to(o.m_AveragingWindow);
    o.m_AveragingWindowIsSet = true;
  }
  if (j.find("maxDataBurstVol") != j.end()) {
    j.at("maxDataBurstVol").get_to(o.m_MaxDataBurstVol);
    o.m_MaxDataBurstVolIsSet = true;
  }
  if (j.find("extMaxDataBurstVol") != j.end()) {
    j.at("extMaxDataBurstVol").get_to(o.m_ExtMaxDataBurstVol);
    o.m_ExtMaxDataBurstVolIsSet = true;
  }
}

int32_t QosCharacteristics::getR5qi() const {
  return m_r_5qi;
}
void QosCharacteristics::setR5qi(int32_t const value) {
  m_r_5qi = value;
}
oai::model::common::QosResourceType QosCharacteristics::getResourceType()
    const {
  return m_ResourceType;
}
void QosCharacteristics::setResourceType(
    oai::model::common::QosResourceType const& value) {
  m_ResourceType = value;
}
int32_t QosCharacteristics::getPriorityLevel() const {
  return m_PriorityLevel;
}
void QosCharacteristics::setPriorityLevel(int32_t const value) {
  m_PriorityLevel = value;
}
int32_t QosCharacteristics::getPacketDelayBudget() const {
  return m_PacketDelayBudget;
}
void QosCharacteristics::setPacketDelayBudget(int32_t const value) {
  m_PacketDelayBudget = value;
}
std::string QosCharacteristics::getPacketErrorRate() const {
  return m_PacketErrorRate;
}
void QosCharacteristics::setPacketErrorRate(std::string const& value) {
  m_PacketErrorRate = value;
}
int32_t QosCharacteristics::getAveragingWindow() const {
  return m_AveragingWindow;
}
void QosCharacteristics::setAveragingWindow(int32_t const value) {
  m_AveragingWindow      = value;
  m_AveragingWindowIsSet = true;
}
bool QosCharacteristics::averagingWindowIsSet() const {
  return m_AveragingWindowIsSet;
}
void QosCharacteristics::unsetAveragingWindow() {
  m_AveragingWindowIsSet = false;
}
int32_t QosCharacteristics::getMaxDataBurstVol() const {
  return m_MaxDataBurstVol;
}
void QosCharacteristics::setMaxDataBurstVol(int32_t const value) {
  m_MaxDataBurstVol      = value;
  m_MaxDataBurstVolIsSet = true;
}
bool QosCharacteristics::maxDataBurstVolIsSet() const {
  return m_MaxDataBurstVolIsSet;
}
void QosCharacteristics::unsetMaxDataBurstVol() {
  m_MaxDataBurstVolIsSet = false;
}
int32_t QosCharacteristics::getExtMaxDataBurstVol() const {
  return m_ExtMaxDataBurstVol;
}
void QosCharacteristics::setExtMaxDataBurstVol(int32_t const value) {
  m_ExtMaxDataBurstVol      = value;
  m_ExtMaxDataBurstVolIsSet = true;
}
bool QosCharacteristics::extMaxDataBurstVolIsSet() const {
  return m_ExtMaxDataBurstVolIsSet;
}
void QosCharacteristics::unsetExtMaxDataBurstVol() {
  m_ExtMaxDataBurstVolIsSet = false;
}

}  // namespace oai::model::pcf
